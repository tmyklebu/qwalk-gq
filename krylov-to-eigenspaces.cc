// Receives Krylov spaces generated by gen-krylov on stdin and generates
// linearly independent subsets of eigenspaces modulo 1999999151.
#include "common.h"
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <string>
#include <map>
using namespace std;

static constexpr int64_t P = 1999999151;
int64_t N;

map<int64_t, vector<vector<uint64_t> > > eigenvectors;

vector<int64_t> roots;

int main() {
  // Roots of p mod 1999999151 according to Maple.
  roots.push_back(1);
  roots.push_back(15);
  roots.push_back(125);
  roots.push_back(127);
  roots.push_back(68005);
  roots.push_back(-25);
  roots.push_back(-23);
  roots.push_back(-9);
  roots.push_back(-1740021529);
  roots.push_back(-1098917485);
  roots.push_back(-608311554);
  roots.push_back(-259972196);
  roots.push_back(-292770911);

  while (1) {
    int64_t p;
    if (1 != scanf("%lli", &p)) goto fail;
    if (p != P) abort();

    int nvecs, n;
    if (2 != scanf("%i %i", &nvecs, &n)) goto fail;
    if (!N) N=n-nvecs;
    if (n-nvecs != N) abort();
    // Each line of input is 98280 vector components followed by nvecs
    // polynomial coefficients.  The vector given by the first 98280 components
    // is p(A) v for some seed vector v; the nvecs coefficients afterward are
    // the coefficients of p.  The last line has a zero vector followed by the
    // minimal polynomial of A over the Krylov space generated by v.  All of
    // this is because gen-krylov generates a row-reduced Krylov space basis
    // together with the transformation used to row-reduce the Krylov space
    // basis.
    vector<vector<int64_t> > vecs;
    vector<vector<int64_t> > coeffs;
    for (int i = 0; i < nvecs; i++) {
      int64_t foo;
      vecs.push_back(vector<int64_t>());
      coeffs.push_back(vector<int64_t>());
      for (int j = 0; j < n-nvecs; j++) {
        if (1 != scanf("%lli", &foo)) goto fail;
        vecs[i].push_back(foo);
      }
      for (int j = 0; j < nvecs; j++) {
        if (1 != scanf("%lli", &foo)) goto fail;
        coeffs[i].push_back(foo);
      }
    }

    for (int64_t r : roots) {
      // Compute poly = coeffs / (x - r).
      vector<int64_t> poly = coeffs.back();
      for (int k = poly.size()-2; k >= 0; k--) {
        poly[k] += (r * poly[k+1]) % P;
        poly[k] %= P;
        if (poly[k] < 0) poly[k] += P;
      }
      // Check that r is a root.  (Strictly speaking, we could simply skip this
      // root.  However, this condition never tripped during our computation.)
      if (poly[0]) abort();
      poly = vector<int64_t>(&poly[1], &poly[poly.size()]);

      // Reconstruct an eigenvector for eigenvalue r.
      vector<uint64_t> eig(N);
      for (int k = poly.size()-1; k >= 0; k--) {
        int64_t coeff = poly[k] * modinv<P>(coeffs[k][k]) % P;
        if (coeff < 0) coeff += P;
        for (int i = 0; i < N; i++)
          eig[i] = (eig[i] + coeff * vecs[k][i]) % P;
        for (int i = 0; i < poly.size(); i++) {
          poly[i] = (poly[i] - coeff * coeffs[k][i]) % P;
          if (poly[i] < 0) poly[i] += P;
        }
      }
      eigenvectors[r].push_back(eig);
      reduce<P>(eigenvectors[r]);

      // Prune possible zero row.
      int idx = 0;
      while (idx < eigenvectors[r].back().size() && !eigenvectors[r].back()[idx]) idx++;
      if (idx == eigenvectors[r].back().size()) eigenvectors[r].pop_back();
    }
    fprintf(stderr, "processed block\n");
    for (const auto &p : eigenvectors) {
      fprintf(stderr, "eig %12lli: %zi\n", p.first, p.second.size());
    }
    printf("\n");
  }
  fail:;
}
